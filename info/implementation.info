Technical Agent-Direct Prompt for Implementation
System Prompt for AI Agent
text
You are a Senior Full-Stack Developer specializing in Next.js, NextUI, TailwindCSS, and Supabase. You're building a PWA chat application with offline-first capabilities and server synchronization.

## PROJECT SPECIFICATIONS

### Tech Stack Requirements:
- Next.js 14+ (App Router)
- NextUI (v2)
- TailwindCSS
- Supabase (already configured)
- PWA with offline-first capabilities -> use the structure found in app\[locale]\chat that you already created, and improve it as needed
- Server-synchronized local database

### Database Structure:
**Supabase Tables:** ( THIS DATABASE EXISTS ALREADY IN SUPABASE )
1. `profiles` table:
   - `id` UUID REFERENCES auth.users(id) PRIMARY KEY
   - (other profile fields)

2. `children` table:
   - `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
   - `parent_id` UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE
   - `name` TEXT
   - (other child fields)

3. `chat_messages` table:
   - `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
   - `child_id` UUID NOT NULL REFERENCES children(id) ON DELETE CASCADE
   - `message_type` ENUM('user', 'assistant')
   - `content` TEXT NOT NULL
   - `timestamp` TIMESTAMPTZ DEFAULT NOW()
   - `parent_message_id` UUID REFERENCES chat_messages(id) (for threading)
   - `is_synced` BOOLEAN DEFAULT false (for sync tracking)

### Local Storage Requirements:
For EACH stored message, MUST include:
1. `child_id` - UUID of the active child (multiple children per device)
2. `date` - Full date of message (YYYY-MM-DD)
3. `time` - Exact time of message (HH:MM:SS)
4. `message_id` - ID of the child's message (user message)
5. `response_id` - ID of the LLM's response (assistant message)
6. `is_offline` - Boolean flag for offline messages
7. `sync_status` - Enum: 'pending', 'synced', 'failed'

### Functional Requirements:
1. Offline-first architecture
2. Automatic sync when online
3. Conflict resolution (last-write-wins with timestamp)
4. Per-child chat separation
5. Message threading support
6. Real-time updates when online

## IMPLEMENTATION TASKS

### TASK 1: Database Schema Enhancement
Extend existing Supabase schema with:
- Create `chat_messages` table as defined above
- Add RLS (Row Level Security) policies for parent/child access
- Create indexes for performance
- Add database functions for sync operations

### TASK 2: Local Database Implementation
Implement PouchDB local storage with:
1. Database structure mirroring Supabase
2. Per-child data partitioning
3. Sync metadata tracking
4. Conflict resolution logic

### TASK 3: Sync Manager Service
Create a robust sync service that:
1. Detects online/offline status
2. Queues offline operations
3. Handles retries with exponential backoff
4. Manages conflicts intelligently
5. Provides sync status UI indicators

### TASK 4: Chat Components
Build Next.js components:
1. Child selector component
2. Chat interface with message threading
3. Offline indicator
4. Sync status display
5. Message input with offline support

### TASK 5: PWA Configuration
Configure Next.js for PWA:
1. Service Worker with cache strategies
2. Manifest configuration
3. Offline fallback pages
4. Install prompt handling

## DELIVERABLES EXPECTED

1. Complete database migration SQL files
2. Local database service with full TypeScript types
3. Sync manager with comprehensive error handling
4. Complete React components with NextUI styling
5. PWA configuration files
6. Utility functions for date/time handling
7. Environment configuration
8. Testing utilities for offline simulation

## CONSTRAINTS

1. Must maintain existing Supabase auth integration
2. Must support multiple children on single device
3. Must preserve message threading relationships
4. Must handle network flakiness gracefully
5. Must provide clear user feedback for sync status
6. Must follow Next.js 14 best practices
7. Must use NextUI components throughout
8. Must be fully typed with TypeScript

## PRIORITY ORDER

1. Local database structure (PouchDB)
2. Basic sync functionality
3. Child switching mechanism
4. Chat UI components
5. PWA optimization
6. Advanced features (typing indicators, read receipts, etc.)

Start by providing the complete implementation plan, then proceed with each task in detail. Provide all code files with exact paths where they should be placed in the Next.js project structure.
Implementation Plan for Your Stack
Phase 1: Database Setup (Supabase)
sql
-- 1. Create chat_messages table
CREATE TABLE chat_messages (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  child_id UUID NOT NULL REFERENCES children(id) ON DELETE CASCADE,
  message_type TEXT NOT NULL CHECK (message_type IN ('user', 'assistant')),
  content TEXT NOT NULL,
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  parent_message_id UUID REFERENCES chat_messages(id),
  is_synced BOOLEAN DEFAULT true,
  local_id TEXT, -- For tracking local-only messages
  device_id TEXT, -- For multi-device conflict resolution
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Add RLS policies
ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;

-- Parents can only see their children's messages
CREATE POLICY "Parents can view their children's messages"
  ON chat_messages FOR SELECT
  USING (
    child_id IN (
      SELECT id FROM children 
      WHERE parent_id = auth.uid()
    )
  );

-- Parents can insert messages for their children
CREATE POLICY "Parents can insert messages for their children"
  ON chat_messages FOR INSERT
  WITH CHECK (
    child_id IN (
      SELECT id FROM children 
      WHERE parent_id = auth.uid()
    )
  );

-- 3. Create indexes
CREATE INDEX idx_chat_messages_child_id ON chat_messages(child_id);
CREATE INDEX idx_chat_messages_timestamp ON chat_messages(timestamp);
CREATE INDEX idx_chat_messages_sync_status ON chat_messages(is_synced) WHERE NOT is_synced;
Phase 2: Project Structure
text
/src
  /app
    /api
      /sync          # Sync endpoints
      /chat          # Chat endpoints
    /chat            # Chat page
    /layout.tsx      # Root layout with PWA
    /service-worker.js
  
  /lib
    /database
      local-db.ts    # PouchDB wrapper
      sync-manager.ts # Sync logic
      types.ts       # TypeScript interfaces
    /supabase
      client.ts      # Supabase client
      types.ts       # Database types
    /hooks
      use-sync.ts    # Sync React hook
      use-chat.ts    # Chat React hook
      use-children.ts # Children management hook
  
  /components
    /chat
      ChatInterface.tsx
      MessageBubble.tsx
      MessageInput.tsx
      ChildSelector.tsx
      SyncStatus.tsx
    /ui
      OfflineIndicator.tsx
      RetryButton.tsx
  
  /utils
    date-formatter.ts
    storage-helper.ts
    conflict-resolver.ts
Phase 3: Core Implementation Files
1. Local Database Service (/lib/database/local-db.ts):

typescript
import PouchDB from 'pouchdb';
import PouchDBFind from 'pouchdb-find';
import PouchDBAuthentication from 'pouchdb-authentication';

PouchDB.plugin(PouchDBFind);
PouchDB.plugin(PouchDBAuthentication);

export interface ChatMessage {
  _id: string; // Local ID
  id?: string; // Server ID (after sync)
  child_id: string;
  message_type: 'user' | 'assistant';
  content: string;
  date: string; // YYYY-MM-DD
  time: string; // HH:MM:SS
  timestamp: string; // ISO string
  parent_message_id?: string;
  message_id?: string; // Child's message ID
  response_id?: string; // LLM response ID
  is_offline: boolean;
  sync_status: 'pending' | 'synced' | 'failed';
  device_id: string;
  _rev?: string; // PouchDB revision
}

export class LocalDatabase {
  private db: PouchDB.Database<ChatMessage>;
  private deviceId: string;

  constructor(childId: string) {
    this.deviceId = this.getDeviceId();
    this.db = new PouchDB(`chat_child_${childId}`);
    this.setupIndexes();
  }

  private getDeviceId(): string {
    // Generate or retrieve device ID
    const storedId = localStorage.getItem('device_id');
    if (storedId) return storedId;
    
    const newId = `device_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem('device_id', newId);
    return newId;
  }

  private async setupIndexes(): Promise<void> {
    await this.db.createIndex({
      index: {
        fields: ['timestamp', 'sync_status', 'child_id']
      }
    });
  }

  async saveMessage(message: Omit<ChatMessage, '_id' | 'device_id' | 'timestamp'>): Promise<ChatMessage> {
    const now = new Date();
    const fullMessage: ChatMessage = {
      ...message,
      _id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      device_id: this.deviceId,
      timestamp: now.toISOString(),
      date: now.toISOString().split('T')[0],
      time: now.toTimeString().split(' ')[0],
    };

    const response = await this.db.put(fullMessage);
    return { ...fullMessage, _rev: response.rev };
  }

  async getMessagesByChild(childId: string, limit = 50): Promise<ChatMessage[]> {
    const result = await this.db.find({
      selector: { child_id: childId },
      sort: [{ 'timestamp': 'desc' }],
      limit
    });
    return result.docs;
  }

  async getUnsyncedMessages(): Promise<ChatMessage[]> {
    const result = await this.db.find({
      selector: { 
        sync_status: 'pending',
        is_offline: true 
      }
    });
    return result.docs;
  }

  async markAsSynced(localId: string, serverId: string): Promise<void> {
    const message = await this.db.get(localId);
    await this.db.put({
      ...message,
      id: serverId,
      sync_status: 'synced',
      is_offline: false
    });
  }

  async deleteLocalMessage(localId: string): Promise<void> {
    const message = await this.db.get(localId);
    await this.db.remove(message);
  }
}
2. Sync Manager (/lib/database/sync-manager.ts):

typescript
import { LocalDatabase, ChatMessage } from './local-db';
import { supabase } from '@/lib/supabase/client';

export class SyncManager {
  private isSyncing = false;
  private syncInterval?: NodeJS.Timeout;
  private onlineStatus = true;

  constructor() {
    this.setupNetworkListeners();
  }

  private setupNetworkListeners(): void {
    if (typeof window !== 'undefined') {
      this.onlineStatus = navigator.onLine;
      
      window.addEventListener('online', () => {
        this.onlineStatus = true;
        this.triggerSync();
      });
      
      window.addEventListener('offline', () => {
        this.onlineStatus = false;
      });
    }
  }

  async syncChildMessages(childId: string): Promise<void> {
    if (this.isSyncing || !this.onlineStatus) return;
    
    this.isSyncing = true;
    const localDB = new LocalDatabase(childId);
    
    try {
      const unsynced = await localDB.getUnsyncedMessages();
      
      for (const message of unsynced) {
        await this.syncSingleMessage(message, localDB);
      }
      
      // Also fetch any server updates
      await this.pullServerUpdates(childId, localDB);
      
    } catch (error) {
      console.error('Sync failed:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  private async syncSingleMessage(message: ChatMessage, localDB: LocalDatabase): Promise<void> {
    try {
      const { data, error } = await supabase
        .from('chat_messages')
        .insert({
          child_id: message.child_id,
          message_type: message.message_type,
          content: message.content,
          parent_message_id: message.parent_message_id,
          local_id: message._id,
          device_id: message.device_id
        })
        .select()
        .single();

      if (error) throw error;
      
      await localDB.markAsSynced(message._id, data.id);
      
    } catch (error) {
      await this.handleSyncError(message, localDB, error);
    }
  }

  private async handleSyncError(
    message: ChatMessage, 
    localDB: LocalDatabase, 
    error: any
  ): Promise<void> {
    console.error('Failed to sync message:', message._id, error);
    
    // Update sync status to failed
    const updated = await localDB.db.get(message._id);
    await localDB.db.put({
      ...updated,
      sync_status: 'failed'
    });
  }

  private async pullServerUpdates(childId: string, localDB: LocalDatabase): Promise<void> {
    const lastSynced = localStorage.getItem(`last_sync_${childId}`);
    
    const { data: serverMessages, error } = await supabase
      .from('chat_messages')
      .select('*')
      .eq('child_id', childId)
      .gt('created_at', lastSynced || new Date(0).toISOString())
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Failed to fetch server updates:', error);
      return;
    }

    // Store server messages locally
    for (const serverMsg of serverMessages) {
      const localMessage: ChatMessage = {
        _id: serverMsg.local_id || `server_${serverMsg.id}`,
        id: serverMsg.id,
        child_id: serverMsg.child_id,
        message_type: serverMsg.message_type as 'user' | 'assistant',
        content: serverMsg.content,
        date: new Date(serverMsg.created_at).toISOString().split('T')[0],
        time: new Date(serverMsg.created_at).toTimeString().split(' ')[0],
        timestamp: serverMsg.created_at,
        parent_message_id: serverMsg.parent_message_id,
        is_offline: false,
        sync_status: 'synced',
        device_id: serverMsg.device_id || 'server'
      };

      try {
        await localDB.db.put(localMessage);
      } catch (err) {
        // Handle conflicts (server wins)
        console.log('Conflict resolved in favor of server');
      }
    }

    // Update last sync time
    localStorage.setItem(`last_sync_${childId}`, new Date().toISOString());
  }

  startAutoSync(childId: string, interval = 30000): void {
    this.stopAutoSync();
    this.syncInterval = setInterval(() => {
      if (this.onlineStatus) {
        this.syncChildMessages(childId);
      }
    }, interval);
  }

  stopAutoSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }
}
3. React Hook for Chat (/lib/hooks/use-chat.ts):

typescript
import { useState, useEffect, useCallback } from 'react';
import { LocalDatabase, ChatMessage } from '@/lib/database/local-db';
import { SyncManager } from '@/lib/database/sync-manager';
import { supabase } from '@/lib/supabase/client';

export const useChat = (childId: string) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isOnline, setIsOnline] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [syncManager] = useState(() => new SyncManager());
  const [localDB] = useState(() => new LocalDatabase(childId));

  // Load initial messages
  useEffect(() => {
    loadMessages();
    syncManager.startAutoSync(childId);
    
    return () => {
      syncManager.stopAutoSync();
    };
  }, [childId]);

  // Network status
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const loadMessages = async () => {
    setIsLoading(true);
    try {
      const localMessages = await localDB.getMessagesByChild(childId);
      setMessages(localMessages);
    } catch (error) {
      console.error('Failed to load messages:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const sendMessage = async (content: string, parentMessageId?: string) => {
    if (!content.trim()) return;

    // Create user message
    const userMessage = await localDB.saveMessage({
      child_id: childId,
      message_type: 'user',
      content: content.trim(),
      parent_message_id: parentMessageId,
      is_offline: !isOnline,
      sync_status: isOnline ? 'pending' : 'pending',
      message_id: `msg_${Date.now()}_user`,
    });

    // Update UI immediately
    setMessages(prev => [userMessage, ...prev]);

    // Generate LLM response (simulated)
    setTimeout(async () => {
      const llmResponse = await localDB.saveMessage({
        child_id: childId,
        message_type: 'assistant',
        content: `This is a response to: "${content}"`,
        parent_message_id: userMessage._id,
        is_offline: !isOnline,
        sync_status: isOnline ? 'pending' : 'pending',
        response_id: `msg_${Date.now()}_assistant`,
      });

      setMessages(prev => [llmResponse, ...prev]);
      
      // Trigger sync if online
      if (isOnline) {
        syncManager.syncChildMessages(childId);
      }
    }, 1000);
  };

  const triggerSync = useCallback(() => {
    if (isOnline) {
      syncManager.syncChildMessages(childId);
    }
  }, [childId, isOnline, syncManager]);

  return {
    messages,
    sendMessage,
    isOnline,
    isLoading,
    triggerSync,
    loadMessages
  };
};
4. Child Selector Component (/components/chat/ChildSelector.tsx):

typescript
import { Select, SelectItem } from '@nextui-org/react';
import { Child } from '@/lib/supabase/types';

interface ChildSelectorProps {
  children: Child[];
  selectedChild: string;
  onChildChange: (childId: string) => void;
  isLoading?: boolean;
}

export default function ChildSelector({
  children,
  selectedChild,
  onChildChange,
  isLoading = false
}: ChildSelectorProps) {
  return (
    <div className="mb-6">
      <Select
        label="Select Child"
        placeholder="Choose a child"
        selectedKeys={[selectedChild]}
        onSelectionChange={(keys) => {
          const key = Array.from(keys)[0] as string;
          onChildChange(key);
        }}
        className="max-w-xs"
        isLoading={isLoading}
        disabled={isLoading}
      >
        {children.map((child) => (
          <SelectItem key={child.id} value={child.id}>
            {child.name}
          </SelectItem>
        ))}
      </Select>
      
      {selectedChild && (
        <p className="text-sm text-gray-500 mt-2">
          Chat history is saved separately for each child
        </p>
      )}
    </div>
  );
}
5. Main Chat Interface (/components/chat/ChatInterface.tsx):

typescript
import { Card, CardBody, ScrollShadow } from '@nextui-org/react';
import MessageBubble from './MessageBubble';
import MessageInput from './MessageInput';
import SyncStatus from './SyncStatus';
import { ChatMessage } from '@/lib/database/local-db';

interface ChatInterfaceProps {
  messages: ChatMessage[];
  onSendMessage: (content: string, parentId?: string) => void;
  isOnline: boolean;
  onSync: () => void;
  isLoading: boolean;
  childName: string;
}

export default function ChatInterface({
  messages,
  onSendMessage,
  isOnline,
  onSync,
  isLoading,
  childName
}: ChatInterfaceProps) {
  const sortedMessages = [...messages].sort(
    (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
  );

  return (
    <div className="flex flex-col h-[calc(100vh-200px)]">
      <div className="mb-4">
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-bold">Chat with {childName}</h1>
          <SyncStatus isOnline={isOnline} onSync={onSync} />
        </div>
      </div>
      
      <Card className="flex-grow mb-4">
        <CardBody className="p-0">
          <ScrollShadow className="h-[400px] p-4">
            {sortedMessages.length === 0 ? (
              <div className="text-center py-8 text-gray-500">
                {isLoading ? 'Loading messages...' : 'No messages yet. Start a conversation!'}
              </div>
            ) : (
              <div className="space-y-4">
                {sortedMessages.map((message) => (
                  <MessageBubble
                    key={message._id}
                    message={message}
                    isOnline={isOnline}
                  />
                ))}
              </div>
            )}
          </ScrollShadow>
        </CardBody>
      </Card>
      
      <MessageInput
        onSendMessage={onSendMessage}
        disabled={isLoading}
        isOnline={isOnline}
      />
    </div>
  );
}
Phase 4: PWA Configuration
/next.config.js:

javascript
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true,
  disable: process.env.NODE_ENV === 'development',
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
      handler: 'CacheFirst',
      options: {
        cacheName: 'google-fonts-cache',
        expiration: {
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
        }
      }
    },
    {
      urlPattern: /^https:\/\/fonts\.gstatic\.com\/.*/i,
      handler: 'CacheFirst',
      options: {
        cacheName: 'gstatic-fonts-cache',
        expiration: {
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
        }
      }
    },
    {
      urlPattern: /\/api\/.*/i,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'api-cache',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 60 * 60 * 24 // 24 hours
        },
        networkTimeoutSeconds: 10
      }
    },
    {
      urlPattern: /\/_next\/image\?url=.+/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'next-image-cache',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
        }
      }
    },
    {
      urlPattern: /\.(?:eot|otf|ttc|ttf|woff|woff2|font.css)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-font-assets',
        expiration: {
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
        }
      }
    },
    {
      urlPattern: /\.(?:jpg|jpeg|gif|png|svg|ico|webp)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-image-assets',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
        }
      }
    },
    {
      urlPattern: /\/_next\/static\/.*/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'next-static-assets',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
        }
      }
    },
    {
      urlPattern: /\.(?:js|css)$/i,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'static-js-css-assets',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
        }
      }
    }
  ]
});

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  images: {
    domains: ['your-supabase-domain.supabase.co'],
  },
};

module.exports = withPWA(nextConfig);
/public/manifest.json:

json
{
  "name": "Children Chat PWA",
  "short_name": "KidsChat",
  "description": "Offline-first chat application for children with parent supervision",
  "theme_color": "#ffffff",
  "background_color": "#ffffff",
  "display": "standalone",
  "orientation": "portrait",
  "scope": "/",
  "start_url": "/",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
Phase 5: Installation & Setup Commands
bash
# 1. Install required packages
npm install pouchdb pouchdb-find pouchdb-authentication
npm install next-pwa workbox-webpack-plugin